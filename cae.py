# -*- coding: utf-8 -*-
"""CAE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1on1b9KDogBrzYw1z1MopbUYjEfLteD2W
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
import numpy as np
from PIL import Image
from sklearn.metrics import confusion_matrix
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.layers import Conv2D, Flatten, MaxPooling2D, AveragePooling2D, UpSampling2D, BatchNormalization, Activation
from matplotlib import pyplot as plt
import pydot

# %matplotlib inline

def normalize(x, mean, std):
    return (x - mean) / std


def denormalize(x, mean, std):
    return ((x * std) + mean) * 255.0


# adapted from: https://stackoverflow.com/questions/41908379/keras-plot-training-validation-and-test-set-accuracy
def plot_error(history, learning_rate, batch_size, description):
    plt.plot(history.history['loss'])
    plt.plot(history.history['val_loss'])
    plt.title(f'model loss with learning rate {learning_rate} and batch size {batch_size}')
    plt.ylabel('loss')
    plt.xlabel('epoch')
    plt.legend(['train', 'validation'], loc='upper right')
    plt.savefig(f'{description}.png')
    plt.show()

(x_train, y_train), (x_test, y_test) = tf.keras.datasets.cifar10.load_data()
x_complete = np.concatenate([x_train, x_test])

np.random.shuffle(x_complete)
x_complete_norm = x_complete / 255.0
# x_complete_mean = x_complete_norm.mean(axis=(0, 1, 2), keepdims=True)
# x_complete_std = x_complete_norm.std(axis=(0, 1, 2), keepdims=True)
# x_complete_norm = normalize(x_complete, x_complete_mean, x_complete_std)

train_size = int(0.8 * len(x_complete_norm))
val_size = int(0.1 * len(x_complete_norm))

x_train, x_remaining = np.split(x_complete_norm, [int(0.8 * len(x_complete_norm))])
x_val, x_test = np.split(x_remaining, [int(0.5 * len(x_remaining))])

kernel_size = 3
stride = 1
padding = 1
no_channels_ls = 16

input_pixel_ls = 8
latent_space = pow(((input_pixel_ls - kernel_size + 2 * padding) / stride) + 1, 2) * no_channels_ls
print(f'Latent space dimensions: {latent_space}')

train = True

model = Sequential([
            Conv2D(filters=32, kernel_size=(5, 5), strides=(2, 2), input_shape=(32, 32, 3), padding='same'),
            BatchNormalization(),
            Activation("relu"),
            Conv2D(filters=64, kernel_size=(5, 5), strides=(2, 2), padding='same'),
            BatchNormalization(),
            Activation("relu"),
            Conv2D(filters=no_channels_ls, kernel_size=(3, 3), strides=(1, 1), padding='same'),
            Activation("relu"),
            UpSampling2D(size=(2, 2)),
            Conv2D(filters=64, kernel_size=(2, 2), strides=(1, 1), padding='same'),
            Activation("relu"),
            UpSampling2D(size=(2, 2)),
            Conv2D(filters=32, kernel_size=(2, 2), strides=(1, 1), padding='same'),
            Activation("relu"),
            Conv2D(filters=3, kernel_size=(2, 2), strides=(1, 1), activation='sigmoid',
                   padding='same'),
        ])

print(model.summary())
model.save_weights('model.h5')

no_epochs = 10
# learning_rate = [0.1, 0.01, 0.001, 0.0001]
# batch_sizes = [8, 32, 128, 512, 1000]

learning_rate = [0.001]
batch_sizes = [512]

description = "test"

if train:
    for l, b in [(l, b) for l in learning_rate for b in batch_sizes]: 
        print(l,b)
        model.load_weights('model.h5')
        opt = tf.keras.optimizers.Adam()
        model.compile(optimizer=opt, loss='mse', metrics=['mse'])

        
        tf.keras.utils.plot_model(model, to_file=f'model_plot_{description}.png', show_shapes=True, show_layer_names=False)

        history = model.fit(x_train, x_train, batch_size=b,
                            validation_data=(x_val, x_val), epochs=no_epochs, verbose=1)

        plot_error(history, l, b, description)
        plt.show()

        model.save("my_model2")
else:
    model = tf.keras.models.load_model("my_model2")

print('\n# Evaluate on test data')
results = model.evaluate(x_test, x_test, verbose=1)

print('\n# Predict on test data')
predictions = model.predict(x_test, steps=1, verbose=1)

# predictions = denormalize(predictions, x_complete_mean, x_complete_std)
# x_test = denormalize(x_test, x_complete_mean, x_complete_std)
img = Image.fromarray(np.uint8(predictions[0] * 255.0), 'RGB')
plt.imshow(img)

img = Image.fromarray(np.uint8(x_test[0] * 255.0), 'RGB')
plt.imshow(img)